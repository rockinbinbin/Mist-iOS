//
//  ContentDeliveryViewController.swift
//  MySampleApp
//
//
// Copyright 2016 Amazon.com, Inc. or its affiliates (Amazon). All Rights Reserved.
//
// Code generated by AWS Mobile Hub. Amazon gives unlimited permission to 
// copy, distribute and modify it.
//
// Source code generated from template: aws-my-sample-app-ios-swift v0.2
//

import UIKit
import MediaPlayer
import AWSMobileHubHelper

class ContentDeliveryViewController: UITableViewController {
    
    fileprivate var prefix: String!
    fileprivate var marker: String?
    fileprivate var contents: [AWSContent]?
    fileprivate var didLoadAllContents: Bool!
    
    fileprivate var manager: AWSContentManager!
    fileprivate let dateFormatter: DateFormatter = DateFormatter()
    
    // MARK: - View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        manager = AWSContentManager.default()
        
        loadMoreContents()
    }
    
    // MARK: - Content Manager user action methods
    
    fileprivate func loadMoreContents() {
        
        manager.listAvailableContents(withPrefix: nil, marker: nil, completionHandler: {[weak self](contents: [AWSContent]?, nextMarker: String?, error: NSError?) -> Void in
            guard let strongSelf = self else { return }
            if let error = error {
                strongSelf.showSimpleAlertWithTitle("Error", message: "Failed to load the list of contents.", cancelButtonTitle: "OK")
                print("Failed to load the list of contents. \(error)")
            }
            if let contents = contents, contents.count > 0 {
                strongSelf.contents = contents
                
                //print(contents)
                
//                if let nextMarker = nextMarker where !nextMarker.isEmpty{
//                    strongSelf.didLoadAllContents = false
//                } else {
//                    strongSelf.didLoadAllContents = true
//                }
//                strongSelf.marker = nextMarker
            }
            } as! ([AWSContent]?, String?, Error?) -> Void)
    }
    
    fileprivate func showDiskLimitOptions() {
        let alertController = UIAlertController(title: "Disk Cache Size", message: nil, preferredStyle: .actionSheet)
        for number: Int in [1, 5, 20, 50, 100] {
            let byteLimitOptionAction = UIAlertAction(title: "\(number) MB", style: .default, handler: {[unowned self](action: UIAlertAction) -> Void in
                self.manager.maxCacheSize = UInt(number) * 1024 * 1024
                })
            alertController.addAction(byteLimitOptionAction)
        }
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        alertController.addAction(cancelAction)
        present(alertController, animated: true, completion: nil)
    }
    
    fileprivate func downloadObjectsToFillCache() {
        manager.listRecentContents(withPrefix: prefix, completionHandler: {[weak self](result: AnyObject?, error: NSError?) -> Void in
            guard let strongSelf = self else { return }
            if let downloadResult: [AWSContent] = result as? [AWSContent] {
                for content: AWSContent in downloadResult {
                    if !content.isCached && !content.isDirectory {
                        strongSelf.downloadContent(content, pinOnCompletion: false)
                    }
                }
            }
            } as! (Any?, Error?) -> Void)
    }
    
    // MARK: - Content user action methods
    
    fileprivate func showActionOptionsForContent(_ rect: CGRect, content: AWSContent) {
        
        let alertController = UIAlertController(title: nil, message: nil, preferredStyle: .actionSheet)
        if alertController.popoverPresentationController != nil {
            alertController.popoverPresentationController?.sourceView = self.view
            alertController.popoverPresentationController?.sourceRect = CGRect(x: rect.midX, y: rect.midY, width: 1.0, height: 1.0)
        }

        if content.isCached {
            let openAction = UIAlertAction(title: "Open", style: .default, handler: {[unowned self](action: UIAlertAction) -> Void in
                DispatchQueue.main.async {
                    self.openContent(content)
                }
                })
            alertController.addAction(openAction)
        }
        
        // Allow opening of remote files natively or in browser based on their type.
        let openRemoteAction = UIAlertAction(title: "Open Remote", style: .default, handler: {[unowned self](action: UIAlertAction) -> Void in
            self.openRemoteContent(content)
            })
        alertController.addAction(openRemoteAction)
        
        
        // If the content hasn't been downloaded, and it's larger than the limit of the cache,
        // we don't allow downloading the contentn.
        if content.knownRemoteByteCount + 4 * 1024 < manager.maxCacheSize {
            // 4 KB is for local metadata.
            var title: String = "Download"
            if content.knownRemoteLastModifiedDate.compare(content.downloadedDate) == .orderedDescending {
                title = "Download Latest Version"
            }
            
            let downloadAction = UIAlertAction(title: title, style: .default, handler: {[unowned self](action: UIAlertAction) -> Void in
                self.downloadContent(content, pinOnCompletion: false)
                })
            alertController.addAction(downloadAction)
        }
        
        let downloadAndPinAction = UIAlertAction(title: "Download & Pin", style: .default, handler: {[unowned self](action: UIAlertAction) -> Void in
            self.downloadContent(content, pinOnCompletion: true)
            })
        alertController.addAction(downloadAndPinAction)
        
        if content.isCached {
            if content.isPinned {
                let unpinAction = UIAlertAction(title: "Unpin", style: .default, handler: {[unowned self](action: UIAlertAction) -> Void in
                    content.unPin()
                    })
                alertController.addAction(unpinAction)
            } else {
                let pinAction = UIAlertAction(title: "Pin", style: .default, handler: {[unowned self](action: UIAlertAction) -> Void in
                    content.pin()
                    })
                alertController.addAction(pinAction)
            }
            let removeAction = UIAlertAction(title: "Delete Local Copy", style: .destructive, handler: {[unowned self](action: UIAlertAction) -> Void in
                content.removeLocal()
                })
            alertController.addAction(removeAction)
        }
        
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel, handler: nil)
        alertController.addAction(cancelAction)
        present(alertController, animated: true, completion: nil)
    }
    
    fileprivate func downloadContent(_ content: AWSContent, pinOnCompletion: Bool) {
        content.download( with: .ifNewerExists, pinOnCompletion: pinOnCompletion, progressBlock: {[weak self](content: AWSContent?, progress: Progress?) -> Void in
            guard let strongSelf = self else { return }
            if strongSelf.contents!.contains( where: {$0 == content}) {
                let row = strongSelf.contents!.index(where: {$0 == content})!
                let indexPath = IndexPath(row: row, section: 0)
                strongSelf.tableView.reloadRows(at: [indexPath], with: .none)
            }
            }, completionHandler: {[weak self](content: AWSContent?, data: Data?, error: NSError?) -> Void in
                guard let strongSelf = self else { return }
                if let downloadError: NSError = error {
                    print("Failed to download a content from a server.\(downloadError)")
                    strongSelf.showSimpleAlertWithTitle("Error", message: "Failed to download a content from a server.", cancelButtonTitle: "OK")
                }
            } as! (AWSContent?, Data?, Error?) -> Void)
    }
    
    fileprivate func openContent(_ content: AWSContent) {
        
    }
    
    fileprivate func openRemoteContent(_ content: AWSContent) {
        content.getRemoteFileURL(completionHandler: { (url: URL?, error: NSError?) -> Void in
            guard let url = url else {
                print("Error getting URL for file. \(error)")
                return
            }
            print(url)
        } as! (URL?, Error?) -> Void)
    }
}

// MARK: - Utility

extension ContentDeliveryViewController {
    fileprivate func showSimpleAlertWithTitle(_ title: String, message: String, cancelButtonTitle cancelTitle: String) {
        let alertController = UIAlertController(title: title, message: message, preferredStyle: .alert)
        let cancelAction = UIAlertAction(title: cancelTitle, style: .cancel, handler: nil)
        alertController.addAction(cancelAction)
        present(alertController, animated: true, completion: nil)
    }
}

extension AWSContent {
    fileprivate func isAudioVideo() -> Bool {
        let lowerCaseKey = self.key.lowercased()
        return lowerCaseKey.hasSuffix(".mov")
            || lowerCaseKey.hasSuffix(".mp4")
            || lowerCaseKey.hasSuffix(".mpv")
            || lowerCaseKey.hasSuffix(".3gp")
            || lowerCaseKey.hasSuffix(".mpeg")
            || lowerCaseKey.hasSuffix(".aac")
            || lowerCaseKey.hasSuffix(".mp3")
    }
    
    fileprivate func isImage() -> Bool {
        let lowerCaseKey = self.key.lowercased()
        return lowerCaseKey.hasSuffix(".jpg")
            || lowerCaseKey.hasSuffix(".png")
            || lowerCaseKey.hasSuffix(".jpeg")
    }
}

extension UInt {
    fileprivate func aws_stringFromByteCount() -> String {
        if self < 1024 {
            return "\(self) B"
        }
        if self < 1024 * 1024 {
            return "\(self / 1024) KB"
        }
        if self < 1024 * 1024 * 1024 {
            return "\(self / 1024 / 1024) MB"
        }
        return "\(self / 1024 / 1024 / 1024) GB"
    }
}

extension String {
    fileprivate func getLastPathComponent() -> String {
        let nsstringValue: NSString = self as NSString
        return nsstringValue.lastPathComponent
    }
}
